TDA Pila
1)	Definir el TDA Pila, listando las operaciones asociadas y establecer sus precondiciones.

public interface PilaTDA(){
	void InicializarPila();
	void Apilar(int x);
	void Desapilar();
	int Tope();
	boolean PilaVacia();
}

2) A partir del TDA Pila definido, escribir distintos métodos que permitan
a) Pasar una Pila a otra (dejándola en orden inverso)
	
public void PasarPila( PilaTDA origen, PilaTDA destino){
	while (!origen.PilaVacia()){
		destino.Apilar(origen.Tope ());
		origen.Desapilar();
	}
}

b) Copiar una Pila en otra (dejándola en el mismo orden que la original)

public void copiaPila(PilaTDA origen, PilaTDA auxiliar, PilaTDA destino){
	while (!origen.PilaVacia()){
		auxiliar.Apilar(origen.Tope ());
		origen.Desapilar();
	}
	while (!auxiliar.PilaVacia()){
		destino.Apilar(auxiliar.Tope());
		auxiliar.Desapilar();
	}
}


c) Invertir el contenido de una Pila.

public void invertirPila(PilaTDA origen, PilaTDA auxiliar1, PilaTDA auxiliar2){
	while (!origen.PilaVacia()){
		auxiliar1.Apilar(origen.Tope ());
		origen.Desapilar();
	}
	while (!auxiliar1.PilaVacia()){
		auxiliar2.Apilar(auxiliar1.Tope ());
		auxiliar1.Desapilar();
	}
	while (!auxiliar2.PilaVacia()){
		origen.Apilar(auxiliar2.Tope ());
		auxiliar2.Desapilar();
	}
}

d) Contar los elementos de una Pila

public int ContarElementos(PilaTDA p){
	int contador = 0;
	while (!p.PilaVacia()){
		contador = ++contador;
		p.Desapilar();
	}
	return contador;
}

e) Sumar los elementos de una Pila

public int SumarElementos(PilaTDA p){
	int suma = 0;
	while (!p.PilaVacia()){
		suma = suma + p.Tope ();
		p.Desapilar();
	}
	return suma;
}

f) Calcular el promedio de los elementos de una Pila
public float PromedioElementos(PilaTDA p){
	int contador = 0;
	int suma = 0;
	float promedio = 0;
	while (!p.PilaVacia()){
		contador ++;
		suma = suma + p.Tope ();
		p.Desapilar();
	}
	promedio = contador/suma;
	return promedio;
}

TDA Cola
2)	Definir el TDA Cola, listando las operaciones asociadas y establecer sus precondiciones.

public interface ColaTDA(){
	void InicializarCola();
	void Acolar(int x);
	void Desacolar();
	int Primero();
	boolean ColaVacia();
}

4) A partir del TDA Cola definido, escribir distintos métodos que permitan
a) Pasar una Cola a otra

public void NuevaCola(ColaTDA origen, ColaTDA destino){
	while (!origen.ColaVacia()){
		destino.Acolar(origen.Primero());
		origen.Desacolar();
	}
}

b) Invertir el contenido de una Cola (pueden usarse Pilas auxiliares)

public void InvertirCola(ColaTDA origen, PilaTDA auxiliar){
	while (!origen.ColaVacia()){
		auxiliar.Apilar(origen.Primero());
		origen.Desacolar();
	}
	while (!auxiliar.PilaVacia()){
		origen.Acolar(auxiliar.Tope());
		auxiliar.Desapilar();
	}
}

c) Invertir el contenido de una Cola (NO pueden usarse Pilas auxiliares)

public void InvertirCola2(ColaTDA cola, ColaTDA auxiliar){
	int [] arreglo;
	int contador;
	
	contador == 0;
	
	while(!cola.ColaVacia()){
		auxiliar.Acolar(cola.Primero);
		contador == ++contador;
		cola.Desacolar;
	}
	
	for(i==contador; contador != 0; --contador){
		cola.Acolar(arreglo[i]);
	}
}

d) Determinar si el final de la Cola C1 coincide o no con la Cola C2.

public boolean CompararFinales(ColaTDA cola1, ColaTDA cola2){
	int final1, final2;
	boolean resultado;
	while(!cola1.ColaVacia(){
		final1 = cola1.Primero();
		cola1.Desacolar();
	}
	while(!cola2.ColaVacia(){
		final2 = cola2.Primero();
		cola2.Desacolar();
	}
	if(final1 == final2){
		resultado = true;
	}
	else{
		resultado = false;
	}
	
	return resultado;
}

e) Determinar si una Cola es capicúa o no. Para ser capicúa debe cumplir que el primer elemento es igual al último, el segundo igual al penúltimo, etc.

public boolean ColaCapicua(ColaTDA origen, ColaTDA caux PilaTDA paux){
	int elemento1, elemento2;
	boolean resultado;
	while (!origen.ColaVacia()){
		caux.Acolar(origen.Primero());
		paux.apilar(origen.Primero());
		origen.Desacolar();
	}

	elemento1 == caux.Primero;
	elemento2 == paux.Tope;
	
	while(!caux.ColaVacia() && !paux.PilaVacia){
		if(elemento1 = elemento2){
			caux.Desacolar();
			paux.Desapilar();
			elemento1 == caux.Primero;
			elemneto2 == paux.Tope;
			resultado == true;
		}
		else{
			resultado == false;
		}
	}
		
	return resultado;
}

f) Determinar si la Cola C1 es la inversa de la Cola C2. Dos Colas serán inversas, si tienen los mismos elementos pero en orden inverso.

public boolean ColasInversas(ColaTDA cola1, ColaTDA cola2 PilaTDA paux){
	int elemento1, elemento2;
	boolean resultado;
	while (!cola2.ColaVacia()){
		paux.apilar(cola2.Primero());
		cola2.Desacolar();
	}

	elemento1 == cola1.Primero;
	elemento2 == paux.Tope;
	
	while(!cola1.ColaVacia() && !paux.PilaVacia){
		if(elemento1 = elemento2){
			cola1.Desacolar();
			paux.Desapilar();
			elemento1 == cola1.Primero;
			elemneto2 == paux.Tope;
			resultado == true;
		}
		else{
			resultado == false;
		}
	}
		
	return resultado;
}

TDA Cola con Prioridades
5) Definir el TDA Cola con prioridades, listando las operaciones asociadas y establecer sus precondiciones.

public interface ColaPrioridadesTDA(){
	void InicializarCola();
	void AcolarPrioridad(intx, int prioridad);
	void Desacolar();
	int Primero();
	int Prioridad();
	boolean ColaVacia();
}

6) A partir del TDA Cola con prioridades definido, escribir un método que permita
a) Combinar dos colas con prioridades CP1 y CP2, generando una nueva cola con prioridades. Considerar que a igual prioridad, los elementos de la CP1 son más prioritarios que los de la CP2.

public void nuevaColaPrioridad(ColaPrioridadTDA CP1, ColaPrioridadTDA CP2, ColaPrioridadTDA CPNueva){
	while(!CP1.ColaVacia() && !CP2.ColaVacia()){
		if(CP1.Prioridad>CP2.Prioridad || CP1.Prioridad=CP2.Prioridad){
			CPNueva.AcolarPrioirdad(Primero(CP1));
			CPNueva.AcolarPrioirdad(Primero(CP2));
			
			CP1.Desacolar:
			CP2.Desacolar;
		}
		else(CP1.Prioridad<CP2.Prioridad){
			CPNueva.AcolarPrioirdad(Primero(CP2));
			CPNueva.AcolarPrioirdad(Primero(CP1));
			
			CP1.Desacolar:
			CP2.Desacolar;
		}
	}
}

b) Determinar si dos Colas con prioridad son idénticas.

public boolean ColasPrioridadIdenticas(ColaPrioridadTDA CP1, ColaPrioridadTDA CP2){
	boolean resultado;
	
	while(!CP1.ColaVacia && !CP2.ColaVacia){
		if(CP1.Primero=CP2.Primero && CP1.Prioridad=CP2.Prioridad){
			resultado == true;
			CP1.Desacolar;
			CP2.Desacolar;
		}
		else{
			resultado == false;
		}
	}
	
	return resultado;
}

Implementaciones y Costos
7) Escribir al menos dos implementaciones distintas (basadas en arreglos) del TDA Pila definido en 1). Comparar los costos de cada una de las operaciones.

public class Pila implements PilaTDA{
	int [] a; 
	int indice;

	public void InicializarPila(){
		a = new int[100];
		indice = 0;
	}

	public void Apilar(int x){
		a[indice] = x;
		indice++;
	}
	
	public void Desapilar(){
		indice --;
	}

	public boolean PilaVacia(){
		return (indice == 0);
	}

	public int Tope (){
		return a[indice -1];
	}
}

8) Escribir al menos dos implementaciones distintas (basadas en arreglos) del TDA Cola definido en 3). Comparar los costos de cada una de las operaciones.

public class Cola implements ColaTDA{
	int [] a;
	int indice;
	
	public void InicializarPila(){
		a = new int[100];
		indice = 0;
	}
	
	public void Acolar(int x){ 
		a[indice] = x;
		indice++;
	}
	
	public void Desacolar(){
		for(int i = 0; i < indice -1; i++){
			a[i] = a[i +1];
		}
		indice --;
	}
	
	public boolean ColaVacia(){
		return(indice == 0);
	}
	
	public int Primero(){
		return a[0];
	}
}


9) Escribir al menos dos implementaciones distintas (basadas en arreglos) del TDA Cola con prioridades definido en 5). Comparar los costos de cada una de las operaciones.

public class ColaPrioridad implements ColaPrioridadTDA{
	class Elemento{
		int valor;
		int prioridad;
	}

	Elemento[] elementos;
	int indice;

	public void InicializarCola(){
		indice = 0;
		elementos = new Elemento[100];
	}
	
	public void AcolarPrioridad(int x, int prioridad){
		int j = indice;
		
		for (; j > 0 && elementos[j-1].prioridad >= prioridad; j--){
			elementos[j] = elementos[j-1];
		}
		elementos[j]= new Elemento();
		elementos[j].valor=x;
		elementos[j].prioridad = prioridad;
		indice++;
	}
	
	public void Desacolar(){
		elementos[indice - 1] = null ;
		indice --;
	}
	
	public int Primero(){
		return elementos[indice -1].valor;
	}
	
	public boolean ColaVacia(){
		return ( indice == 0);
	}

	public int Prioridad(){
		return elementos[indice -1]. prioridad;
	}
}
